## 第二回kubectl関連

Namespqceの分割粒度に関して、権限分離性の観点から内クロサービスを開発するチームごとに分割するのが良い。

プロダクション環境、ステージング環境、開発環境をnamespaceで分割するのは得策ではなく、クラスタごと分けるべきである。

kubectlはkubeconfig(~/.kube/config)に書かれている情報を使用して接続を行い,kubeconfigもマニフェストと同じフォーマットで記述する。

kubeconfigで具体的に設定を行う部分はclusters/users/contextaの三種類で複数登録可能
cluustersには接続先クラスタの情報、usersには認証情報、contextはuserとclustersのペアとnamespaceを定義します。

kubeconfigは直接やkubectlを通して編集できる。（kubectx,kubensもある）

k8sのリソースの処理は非同期のため、--waitオプションをつけるとリソース削除などを待ってからコマンドを実行できる。

すぐリソースを削除するのは--grace-period 0か--force（v1.18以降は動作が同じ）

--nowは即削除じゃない

kubectl apply コマンドは変更差分がある場合には変更処理を行い、ない時は何もしない、リソースがないときは新規作成する。
基本的にはapplyを使った方が良い。

理由1. スクリプトやCI/CDなどに組み込むことを考えると条件分岐はない方が良いから
理由２. kubectl createはリソース作成がデータ保存されないので差分検出時にエラーが起こる可能性があるから

server-side applyというのもある。

kubectl wait コマンドは連続的にリソースを操作するときに役立つ

### マニフェストファイルの設計

実行順序を厳密にしたい場合、リソースの結合度が強い場合はマニフェストをまとめると良い。

一方で共通で利用する設定ファイルやパスワードなどは様々なリソースから利用される場合があるので別のマニフェストに分けるべきである。

「--」 でくぎる

そこまで規模が大きくない場合はシステム全体を構成するための全てのマイクロサービスのマニフェストを１つのディレクトリにまとめると良い。
そうすることで、１つのマニフェストファイルを適用すれば特定のマイクロサービスをアップデートできるし、ディレクトリを指定すれば全てのマイクロサービス、すなわちシウテム全体のアップデートが可能になる。

大きければ分けても良い。

個々のマイクロサービスは１つのマニフェストがいるで全てのリソースを管理しても良いが、マイクロサービス後とにディレクトリを作っておくことでリソースの種類ごとにファイルを作れる。
しかし、この方法は可読性が高まる一方で適用の順序が難しくなるデメリットもある。

コンウェイの法則　→　組織図とマニフェストの管理構造やマイクロサービスアーキテクチャの構造がにていること

アノテーション　→　リソースに端するメモ書き、メタデータ　前回適用したマニフェストなど

kubectl --prune オプション　→　deleteも行う　（マニフェストから削除されたリソースを検知する）　※まだalpha機能
基本的に危ないのでラベル指定する。

edit set get describe top exec(exec -it pod名 -- bin/bash )

port-forward debug logs

コンテナ上で起動するアプリケーションは標準出力、標準エラー出力にログを出すのがベストプラクティス

Sternを使うと便利

podが起動しない時の原因

確認方法
- kubectl logs
- kubectl describe
    - リソースが枯渇していてスケジューリングできない
    - スケジューリングポリシーに該当するノードがない
    - ボリュームのマウントに失敗した
- kubectl run
    - コンテナ環境やアプリケーションに問題がある時
    - 起動したアプリが呈しているとpod求まるのでexec が使えない
    



