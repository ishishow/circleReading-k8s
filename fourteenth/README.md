# マニフェストの汎用化

## Helm

- Helm は Kubernetes のパッケージマネージャです。Kubernetes と Helm の関係は、RedHat 系 Linux における yum や Debian 系 Linux における apt との関係に相当します。
- Helm はオープンソースソフトウェアとして公開されており、既に様々なパッケージが用意されています。
- 例えば Redis クラスタや WordPress 環境のソフトウェアを１コマンドで Kubernetes クラスタ上にデプロイすることが可能です。
- また、ローリングアップデートなどにも対応しているものが多く、Kubernetes で実行するのに適切な設定がされた状態で利用ができるのも良いところです

## 機能

- 「Chart」と呼ばれる設定ファイルに基づいた各種リソースの自動作成
- デプロイされたアプリケーションの削除・更新といった管理
- リポジトリで公開されている Chart の検索やダウンロード、インストール
- Chart のパッケージ化やリポジトリへのアップロード

## 「メリット」リリースバージョニング

> Release を使うことで、Helm は複数のリソースからなる一つのアプリケーション単位で世代管理してくれる。これはすなわち、サービスの単位でロールバックが可能ということだ。ちなみに、Kubernetes の Deployments がやってくれる世代管理はリソース単位。ちなみに、先ほど紹介した Kustomize にはこの機能はなく、現状 Helm の大きなアドバンテージと言っていいだろう。

## 「メリット」 Helm Chart Repository

> 例えば、datadog をクラスタにデプロイしたいとする。自分で Deployment を書いて、ServiceAccount や ConfigMap を追加して、、とやるのが通常。Helm にはみんながよく使うツールやライブラリをパッケージ化したチャートが豊富に用意されている。チャートはもちろん自作もできる。なので、datadog 入れたいってなったらチャートを持ってきて、動的にパラメータ変えたいとこ変えて install してしまえば done となる。要は、人気のツール使うときにごにょごにょ書かなきゃいけないのをほとんど書かなくてよくなって、設定値を渡すだけでよくなる。これが Package の恩恵。

## 「デメリット」 “宣言的”ではない

> 動的に値を埋め込めるのはいい。パッケージングできるのもいい。ただ、Helm を使った結果、宣言的な管理が難しくなる。helm install --set や helm install --values という形のコマンドインタフェースしか持っていないため、パラメーター＋テンプレートや複数の Release を宣言的に管理できない。これを解決するために helmfile という OSS がある。helmfile を使うと、状態のあるべき姿を helmfile.yaml に記述することで、あとは helmfile apply するだけでいい。

## 「デメリット」 黒魔術を使ったテンプレートファイル

> Helm のチャートテンプレートのなかを覗くと突然 {{ .Values.hoge }} とか {{ include "temaki.labels" . | indent 4 }}とか出てくる。これの正体は、Go の Template という標準ライブラリの記法だ。Helm のソースコードは Go で書かれていて、パラメーターの変数埋め込みの機能の部分はこれがそのまま採用されている。なので、良い感じのチャートを作るためには頑張ってこちらを学習する必要がある。もともと Go を書いている人ならまだ良いけど、初見だとなんだこの記法は・・となるんじゃないだろうか？というわけでプログラミング言語の標準そのままなので、やろうと思えばやりたいことは割となんでもできる。for とか if とか。最初は・・・マニフェストの定義をしていたつもりでも気づいたらあなたはプログラミングをしていることだろう。。。Helm を触っていたつもりでも気づいたら Go を書いている人になっている。。。その柔軟性ゆえに、Helm チャートは黒魔術化しやすい。

## Kubernetes 上へのデプロイ管理ツールとして必要十分、ただ設定関連には慣れが必要

> ここまでで解説してきたとおり、Helm の本質はパラメータとテンプレートを使ったマニフェストファイルの自動生成であり、提供している機能は非常にシンプルだ。とはいえ、Kubernetes クラスタにアプリケーションを柔軟性のある形でデプロイするという問題に対しては十分な解決手段となっている。ただ、多くの Chart では設定できるパラメータが膨大になっているという問題もある。柔軟性を確保するためには仕方がないのかもしれないが、ユーザービリティとしてはあまり好ましくない。

> 一方で、ひな形の自動生成機能を活用することで、シンプルなものであれば比較的容易に独自の Chart を作成できる点は便利だ。また、アップグレードやロールバックの仕組みが用意されている点も有用だ。既存の Chart を使わず、単に独自のアプリケーションのデプロイツールとして利用するだけでも十分に利用価値がある。すでに Helm は Kubernetes の事実上標準的なデプロイ管理ツールとなっていることもあり、習得しておいて損はないだろう。

## Iac のアプローチ

- 宣言型プログラミング（機能的）は「何」
  - 最終的なターゲット設定が何であるべきかに焦点を当てている。
  - 目的の様子（所望の状態？）を定義すると、システムはその様子を達成するために必要な何かを実行する。
- 命令型プログラミング（手続き的）は「どのように」
  - 最終的なターゲット設定を満たすために、インフラがどのように変化すべきかに焦点を当てている。
  - 目的の様子で終了するために、適切な順序で実行する必要があるコマンドを定義する。
- インテリジェント（環境認識）は「なぜ」
  - 同じインフラストラクチャで実行されている複数のアプリケーションの全ての相互関係と依存性を考慮し、最終的なターゲット設定が、特定の方法による理由に焦点を当てている。
  - 相互依存（共依存）アプリケーションに影響を与えないように、システムは起こる必要がある何かを処理する前に、目的の状態を決定する。
    環境を意識した状態が IaC の次世代である。
